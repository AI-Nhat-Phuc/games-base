/**
 * Build Character command - Builds a character with sprite and animations
 */

import chalk from 'chalk';
import ora from 'ora';
import path from 'path';
import fs from 'fs-extra';
import https from 'https';
import http from 'http';

interface BuildCharacterOptions {
  name: string;
  sprite?: string;
  walk?: string;
  run?: string;
  attack?: string;
  injured?: string;
  dead?: string;
  output: string;
}

async function buildCharacterCommand(options: BuildCharacterOptions) {
  console.log(chalk.cyan(`\nðŸŽ¨ Building character: ${chalk.bold(options.name)}\n`));

  const spinner = ora('Preparing character data...').start();

  try {
    // Create output directory
    const outputPath = path.resolve(process.cwd(), options.output);
    fs.mkdirSync(outputPath, { recursive: true });

    const characterId = options.name.toLowerCase().replace(/\s+/g, '_');
    const characterData: any = {
      id: characterId,
      name: options.name,
      animations: {},
      generatedAt: new Date().toISOString()
    };

    // Process sprite
    if (options.sprite) {
      spinner.text = 'Processing sprite...';
      characterData.sprite = await processAsset(options.sprite, 'sprite');
    }

    // Process animations
    const animations = [
      { key: 'walk', path: options.walk },
      { key: 'run', path: options.run },
      { key: 'attack', path: options.attack },
      { key: 'injured', path: options.injured },
      { key: 'dead', path: options.dead }
    ];

    for (const anim of animations) {
      if (anim.path) {
        spinner.text = `Processing ${anim.key} animation...`;
        characterData.animations[anim.key] = await processAsset(anim.path, anim.key);
      }
    }

    // Generate character file
    const outputFile = path.join(outputPath, `${characterId}.json`);
    fs.writeFileSync(outputFile, JSON.stringify(characterData, null, 2));

    // Generate TypeScript integration file
    const integrationCode = generateIntegrationCode(characterData);
    const tsFile = path.join(outputPath, `${characterId}.ts`);
    fs.writeFileSync(tsFile, integrationCode);

    spinner.succeed('Character built successfully!');

    console.log(chalk.green('\nâœ… Character files created:\n'));
    console.log(chalk.white(`  ðŸ“„ ${path.relative(process.cwd(), outputFile)}`));
    console.log(chalk.white(`  ðŸ“„ ${path.relative(process.cwd(), tsFile)}`));
    console.log();
    console.log(chalk.cyan('Usage in your game:'));
    console.log(chalk.white(`  import { load${capitalize(characterId)} } from './characters/${characterId}';`));
    console.log(chalk.white(`  const character = await load${capitalize(characterId)}(getGame());`));
    console.log();

  } catch (error) {
    spinner.fail('Failed to build character');
    console.error(chalk.red(error));
    process.exit(1);
  }
}

async function processAsset(assetPath: string, type: string): Promise<any> {
  // Check if it's a URL
  if (assetPath.startsWith('http://') || assetPath.startsWith('https://')) {
    return {
      type: 'url',
      source: assetPath,
      format: path.extname(assetPath).substring(1) || 'png'
    };
  }

  // Local file
  const fullPath = path.resolve(process.cwd(), assetPath);
  
  if (!fs.existsSync(fullPath)) {
    throw new Error(`File not found: ${assetPath}`);
  }

  const ext = path.extname(fullPath).substring(1);
  const data = fs.readFileSync(fullPath);
  const base64 = data.toString('base64');

  return {
    type: 'embedded',
    data: `data:image/${ext};base64,${base64}`,
    format: ext,
    size: data.length
  };
}

function generateIntegrationCode(characterData: any): string {
  const animations = Object.keys(characterData.animations);
  
  return `/**
 * ${characterData.name} Character
 * Generated by games-base CLI
 */

import { GameManager } from '@nhatphucpham/game-core-client';

export async function load${capitalize(characterData.id)}(game: GameManager) {
  const assetLoader = game.getAssetLoader();
  const characterBuilder = game.getCharacterBuilder();

  // Load sprite
  ${characterData.sprite ? `
  const spriteData = ${JSON.stringify(characterData.sprite, null, 2)};
  if (spriteData.type === 'url') {
    await assetLoader.loadImage('${characterData.id}_sprite', spriteData.source);
  } else {
    await assetLoader.loadImage('${characterData.id}_sprite', spriteData.data);
  }
  ` : '// No sprite provided'}

  // Load animations
  ${animations.map(anim => `
  const ${anim}Data = ${JSON.stringify(characterData.animations[anim], null, 2)};
  if (${anim}Data.type === 'url') {
    await assetLoader.loadImage('${characterData.id}_${anim}', ${anim}Data.source);
  } else {
    await assetLoader.loadImage('${characterData.id}_${anim}', ${anim}Data.data);
  }
  `).join('\n')}

  await assetLoader.waitForAll();

  // Create character
  const character = characterBuilder.createCharacter(
    '${characterData.id}',
    '${characterData.name}',
    { x: 100, y: 100 },
    { width: 32, height: 32 },
    { health: 100, maxHealth: 100, speed: 200 }
  );

  // Set sprite
  ${characterData.sprite ? `
  const spriteImage = assetLoader.getImage('${characterData.id}_sprite');
  characterBuilder.setSprite('${characterData.id}', {
    image: spriteImage,
    size: { width: 32, height: 32 }
  });
  ` : ''}

  // Add animations
  ${animations.map(anim => `
  // ${capitalize(anim)} animation
  const ${anim}Image = assetLoader.getImage('${characterData.id}_${anim}');
  characterBuilder.addAnimation('${characterData.id}', {
    name: '${anim}',
    frames: [
      {
        sprite: {
          image: ${anim}Image,
          sourceRect: { x: 0, y: 0, width: 32, height: 32 },
          size: { width: 32, height: 32 }
        },
        duration: 100
      }
      // Add more frames as needed
    ],
    loop: true
  });
  `).join('\n')}

  return character;
}

export const ${characterData.id}Data = ${JSON.stringify(characterData, null, 2)};
`;
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).replace(/_(.)/g, (_, char) => char.toUpperCase());
}

export = buildCharacterCommand;
