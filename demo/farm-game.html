<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üåæ N√¥ng Tr·∫°i Mini - PNP Game Engine Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a4d1a 0%, #2d5a2d 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #fff;
    }
    
    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    .subtitle {
      color: #aaffaa;
      margin-bottom: 20px;
      font-size: 0.9em;
    }
    
    .badge-2-5d {
      display: inline-block;
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      color: #000;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.5em;
      font-weight: bold;
      vertical-align: middle;
      margin-left: 10px;
      text-shadow: none;
    }
    
    .game-container {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    #gameCanvas {
      border: 4px solid #8B4513;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 50%, #7CB342 100%);
    }
    
    .panel {
      background: rgba(0,0,0,0.5);
      border-radius: 10px;
      padding: 15px;
      min-width: 200px;
    }
    
    .panel h3 {
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 8px;
      margin-bottom: 10px;
      color: #4CAF50;
    }
    
    .controls {
      text-align: center;
    }
    
    .arrow-keys {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      gap: 5px;
      justify-content: center;
      margin: 15px 0;
    }
    
    .key-btn {
      width: 50px;
      height: 50px;
      font-size: 20px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: linear-gradient(145deg, #4a4a4a, #333);
      color: #fff;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      transition: all 0.1s;
    }
    
    .key-btn:hover {
      background: linear-gradient(145deg, #5a5a5a, #444);
    }
    
    .key-btn:active, .key-btn.active {
      transform: translateY(2px);
      box-shadow: 0 2px 3px rgba(0,0,0,0.3);
      background: linear-gradient(145deg, #333, #222);
    }
    
    .key-btn.empty {
      visibility: hidden;
    }
    
    .plant-selector {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .plant-btn {
      padding: 10px;
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
      background: #2a2a2a;
      color: #fff;
      text-align: left;
    }
    
    .plant-btn:hover {
      background: #3a3a3a;
    }
    
    .plant-btn.selected {
      border-color: #4CAF50;
      background: #1a3a1a;
    }
    
    .actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 15px;
    }
    
    .action-btn {
      padding: 12px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.2s;
    }
    
    .action-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-plant {
      background: linear-gradient(145deg, #8B4513, #654321);
      color: #fff;
    }
    
    .btn-water {
      background: linear-gradient(145deg, #2196F3, #1976D2);
      color: #fff;
    }
    
    .btn-harvest {
      background: linear-gradient(145deg, #FF9800, #F57C00);
      color: #fff;
    }
    
    .action-btn:hover:not(:disabled) {
      transform: scale(1.02);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .info-panel {
      font-size: 13px;
    }
    
    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .info-label {
      color: #aaa;
    }
    
    .info-value {
      color: #4CAF50;
      font-weight: bold;
    }
    
    .status-msg {
      margin-top: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 5px;
      font-size: 12px;
      color: #ffeb3b;
      min-height: 50px;
    }
    
    .legend {
      margin-top: 10px;
      font-size: 11px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 3px 0;
    }
    
    .legend-color {
      width: 20px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.3);
      transform: skewX(-15deg);
    }
    
    .instructions {
      text-align: center;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      font-size: 12px;
    }
    
    .camera-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }
    
    .camera-btn {
      padding: 8px 12px;
      font-size: 14px;
      font-weight: bold;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background: linear-gradient(145deg, #6366f1, #4f46e5);
      color: #fff;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      transition: all 0.2s;
    }
    
    .camera-btn:hover {
      background: linear-gradient(145deg, #818cf8, #6366f1);
      transform: scale(1.05);
    }
    
    .camera-btn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 3px rgba(0,0,0,0.3);
    }
    
    .camera-angle {
      font-size: 18px;
      font-weight: bold;
      color: #fbbf24;
      min-width: 50px;
      text-align: center;
    }
    
    .mouse-hint {
      text-align: center;
      font-size: 11px;
      color: #aaa;
      margin-top: 8px;
      padding: 5px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
    }
    
    #gameCanvas {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>üåæ N√¥ng Tr·∫°i Mini <span class="badge-2-5d">Top-Down</span></h1>
  <p class="subtitle">Demo s·ª≠ d·ª•ng PNP Game Engine - Top-Down View</p>
  
  <div class="instructions">
    <strong>H∆∞·ªõng d·∫´n:</strong> Di chuy·ªÉn b·∫±ng W/A/S/D ho·∫∑c nh·∫•p chu·ªôt v√†o √¥, xoay camera b·∫±ng Q/E, ch·ªçn lo·∫°i c√¢y, sau ƒë√≥ Gieo h·∫°t ‚Üí T∆∞·ªõi n∆∞·ªõc ‚Üí Thu ho·∫°ch khi c√¢y tr∆∞·ªüng th√†nh
  </div>
  
  <div class="game-container">
    <!-- Left Panel: Controls -->
    <div class="panel controls">
      <h3>üéÆ ƒêi·ªÅu khi·ªÉn</h3>
      <div class="arrow-keys">
        <button class="key-btn empty"></button>
        <button class="key-btn" id="btnW">W</button>
        <button class="key-btn empty"></button>
        <button class="key-btn" id="btnA">A</button>
        <button class="key-btn" id="btnS">S</button>
        <button class="key-btn" id="btnD">D</button>
      </div>
      
      <h3>üì∑ Xoay Camera</h3>
      <div class="camera-controls">
        <button class="camera-btn" id="btnRotateLeft" title="Xoay tr√°i (Q)">‚ü≤ Q</button>
        <span class="camera-angle" id="cameraAngle">0¬∞</span>
        <button class="camera-btn" id="btnRotateRight" title="Xoay ph·∫£i (E)">E ‚ü≥</button>
      </div>
      <div class="mouse-hint">üñ±Ô∏è Nh·∫•p chu·ªôt v√†o √¥ ƒë·ªÉ di chuy·ªÉn</div>
      
      <h3>üå± Ch·ªçn lo·∫°i c√¢y</h3>
      <div class="plant-selector">
        <button class="plant-btn selected" data-plant="carrot">ü•ï C√† r·ªët (3 giai ƒëo·∫°n)</button>
        <button class="plant-btn" data-plant="tomato">üçÖ C√† chua (4 giai ƒëo·∫°n)</button>
        <button class="plant-btn" data-plant="corn">üåΩ Ng√¥ (5 giai ƒëo·∫°n)</button>
        <button class="plant-btn" data-plant="wheat">üåæ L√∫a m√¨ (3 giai ƒëo·∫°n)</button>
      </div>
      
      <div class="actions">
        <button class="action-btn btn-plant" id="btnPlant">üå± Gieo h·∫°t</button>
        <button class="action-btn btn-water" id="btnWater">üíß T∆∞·ªõi n∆∞·ªõc</button>
        <button class="action-btn btn-harvest" id="btnHarvest">üß∫ Thu ho·∫°ch</button>
      </div>
    </div>
    
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Right Panel: Info -->
    <div class="panel info-panel">
      <h3>üìä Th√¥ng tin</h3>
      <div class="info-row">
        <span class="info-label">V·ªã tr√≠:</span>
        <span class="info-value" id="posInfo">(0, 0)</span>
      </div>
      <div class="info-row">
        <span class="info-label">G√≥c camera:</span>
        <span class="info-value" id="cameraInfo">üì∑ 0¬∞</span>
      </div>
      <div class="info-row">
        <span class="info-label">√î hi·ªán t·∫°i:</span>
        <span class="info-value" id="cellInfo">ƒê·∫•t tr·ªëng</span>
      </div>
      <div class="info-row">
        <span class="info-label">C√¢y ƒë√£ ch·ªçn:</span>
        <span class="info-value" id="plantInfo">ü•ï C√† r·ªët</span>
      </div>
      <div class="info-row">
        <span class="info-label">S·ªë ti·ªÅn:</span>
        <span class="info-value" id="moneyInfo">üí∞ 100</span>
      </div>
      <div class="info-row">
        <span class="info-label">Thu ho·∫°ch:</span>
        <span class="info-value" id="harvestInfo">0</span>
      </div>
      
      <div class="status-msg" id="statusMsg">Ch√†o m·ª´ng ƒë·∫øn n√¥ng tr·∫°i! Di chuy·ªÉn ƒë·∫øn √¥ ƒë·∫•t v√† gieo h·∫°t.</div>
      
      <h3>üìñ Ch√∫ th√≠ch</h3>
      <div class="legend">
        <div class="legend-item">
          <span class="legend-color" style="background: #654321;"></span>
          <span>ƒê·∫•t tr·ªëng (c√≥ th·ªÉ gieo)</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #8B7355;"></span>
          <span>H·∫°t gi·ªëng</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #90EE90;"></span>
          <span>C√¢y ƒëang ph√°t tri·ªÉn</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #228B22;"></span>
          <span>S·∫µn s√†ng thu ho·∫°ch</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #808080;"></span>
          <span>Ng√¥i nh√†</span>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    /**
     * Farm Game Demo - 2.5D Isometric Version
     * S·ª≠ d·ª•ng c√°c concept t·ª´ PNP Game Engine:
     * - GameEngine: Game loop, canvas rendering
     * - MapBuilder: Tile-based map v·ªõi 10x10 grid (Isometric)
     * - CharacterBuilder: Player character
     * - InputManager: Keyboard input
     */
    
    // C·∫•u h√¨nh c√¢y tr·ªìng
    const PLANT_CONFIG = {
      carrot: {
        name: 'C√† r·ªët',
        icon: 'ü•ï',
        stages: 3,
        growTime: 3000,
        harvestValue: 15,
        seedCost: 5
      },
      tomato: {
        name: 'C√† chua',
        icon: 'üçÖ',
        stages: 4,
        growTime: 4000,
        harvestValue: 25,
        seedCost: 10
      },
      corn: {
        name: 'Ng√¥',
        icon: 'üåΩ',
        stages: 5,
        growTime: 5000,
        harvestValue: 40,
        seedCost: 15
      },
      wheat: {
        name: 'L√∫a m√¨',
        icon: 'üåæ',
        stages: 3,
        growTime: 2500,
        harvestValue: 10,
        seedCost: 3
      }
    };
    
    // Tr·∫°ng th√°i c√¢y
    const CELL_STATE = {
      EMPTY: 'empty',
      SEEDED: 'seeded',
      GROWING: 'growing',
      READY: 'ready',
      HOUSE: 'house'
    };
    
    // Constants
    const MOVE_DELAY_MS = 150;
    const SPARKLE_ANIMATION_PERIOD_MS = 200;
    const TILE_DEPTH = 15;
    const CANVAS_PADDING_X = 50;
    const CANVAS_PADDING_Y = 150;
    
    // Camera rotation constants - only allow 0¬∞, 90¬∞, 180¬∞, 270¬∞
    const CAMERA_ANGLES = [0, 90, 180, 270];
    const CAMERA_ROTATION_STEP = 90;
    
    // Player rendering constants
    const PLAYER_SHADOW_RADIUS_X = 12;
    const PLAYER_SHADOW_RADIUS_Y = 6;
    const PLAYER_SHADOW_OFFSET_Y = 5;
    const PLAYER_BODY_RADIUS_X = 10;
    const PLAYER_BODY_RADIUS_Y = 18;
    const PLAYER_BODY_OFFSET_Y = -15;
    const PLAYER_BODY_HIGHLIGHT_OFFSET_X = -3;
    const PLAYER_BODY_HIGHLIGHT_OFFSET_Y = -18;
    const PLAYER_BODY_HIGHLIGHT_RADIUS_X = 4;
    const PLAYER_BODY_HIGHLIGHT_RADIUS_Y = 10;
    const PLAYER_HEAD_RADIUS = 10;
    const PLAYER_HEAD_OFFSET_Y = -38;
    const PLAYER_HAT_BRIM_RADIUS_X = 14;
    const PLAYER_HAT_BRIM_RADIUS_Y = 5;
    const PLAYER_HAT_BRIM_OFFSET_Y = -48;
    const PLAYER_HAT_TOP_WIDTH = 16;
    const PLAYER_HAT_TOP_HEIGHT = 10;
    const PLAYER_HAT_TOP_OFFSET_X = -8;
    const PLAYER_HAT_TOP_OFFSET_Y = -58;
    const PLAYER_EYE_RADIUS = 1.5;
    const PLAYER_EYE_OFFSET_X = 3;
    const PLAYER_EYE_OFFSET_Y = -40;
    const PLAYER_SMILE_RADIUS = 4;
    const PLAYER_SMILE_OFFSET_Y = -36;
    
    // House rendering constants
    const HOUSE_FOUNDATION_OFFSET_Y = -10;
    const HOUSE_WALL_HEIGHT = 50;
    const HOUSE_ROOF_HEIGHT = 90;
    const HOUSE_ROOF_OVERHANG = 5;
    const HOUSE_DOOR_WIDTH = 15;
    const HOUSE_DOOR_HEIGHT = 30;
    const HOUSE_DOOR_OFFSET_X = 5;
    const HOUSE_DOOR_OFFSET_Y = 8;
    const HOUSE_WINDOW_SIZE = 15;
    const HOUSE_CHIMNEY_WIDTH = 12;
    const HOUSE_CHIMNEY_HEIGHT = 25;
    const HOUSE_CHIMNEY_CAP_WIDTH = 16;
    const HOUSE_CHIMNEY_CAP_HEIGHT = 5;
    
    // Helper function for smooth movement (defined once, not per frame)
    const smoothMove = (current, target, moveSpeed) => {
      if (Math.abs(current - target) > 1) {
        return current + Math.sign(target - current) * Math.min(moveSpeed, Math.abs(target - current));
      }
      return target;
    };
    
    class FarmGame {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        const ctx = this.canvas.getContext('2d');
        if (!ctx) {
          throw new Error('Could not get 2D context from canvas');
        }
        this.ctx = ctx;
        
        // Top-down grid settings (square tiles instead of isometric)
        this.gridSize = 10;
        this.tileSize = 50;  // Square tile size
        
        // Canvas size ƒë·ªÉ fit grid
        this.canvas.width = this.gridSize * this.tileSize + 100;
        this.canvas.height = this.gridSize * this.tileSize + 100;
        
        // Offset ƒë·ªÉ center map
        this.offsetX = 50;
        this.offsetY = 50;
        
        // Player
        this.player = {
          gridX: 5,
          gridY: 5,
          renderX: 0,
          renderY: 0,
          targetRenderX: 0,
          targetRenderY: 0,
          speed: 300,
          moving: false
        };
        this.updatePlayerTarget();
        this.player.renderX = this.player.targetRenderX;
        this.player.renderY = this.player.targetRenderY;
        
        // Camera rotation state - only 0¬∞, 90¬∞, 180¬∞, 270¬∞ allowed
        this.cameraAngle = 0; // Current camera angle (0, 90, 180, 270)
        this.cameraAngleIndex = 0; // Index in CAMERA_ANGLES array
        
        // Mouse state for click-to-move
        this.mouseTarget = null; // Target grid position when clicking
        
        // Game state
        this.selectedPlant = 'carrot';
        this.money = 100;
        this.harvestCount = 0;
        this.keys = new Set();
        this.lastMoveTime = 0;
        this.moveDelay = MOVE_DELAY_MS;
        
        // Track growing cells for performance optimization
        this.growingCells = [];
        
        // Initialize field (10x10)
        this.field = [];
        this.initField();
        
        // Setup
        this.setupInput();
        this.setupUI();
        
        // Start game loop
        this.lastTime = performance.now();
        this.gameLoop();
        
        this.showStatus('Ch√†o m·ª´ng ƒë·∫øn n√¥ng tr·∫°i! Di chuy·ªÉn b·∫±ng W/A/S/D ho·∫∑c nh·∫•p chu·ªôt. Q/E ƒë·ªÉ xoay camera.');
      }
      
      // Rotate grid coordinates based on camera angle (for rendering)
      rotateGridCoords(gx, gy) {
        const center = (this.gridSize - 1) / 2;
        const rx = gx - center;
        const ry = gy - center;
        
        switch (this.cameraAngle) {
          case 90:
            return { x: center - ry, y: center + rx };
          case 180:
            return { x: center - rx, y: center - ry };
          case 270:
            return { x: center + ry, y: center - rx };
          default: // 0
            return { x: gx, y: gy };
        }
      }
      
      // Inverse rotation for converting screen back to original grid
      inverseRotateGridCoords(gx, gy) {
        const center = (this.gridSize - 1) / 2;
        const rx = gx - center;
        const ry = gy - center;
        
        switch (this.cameraAngle) {
          case 90:
            return { x: center + ry, y: center - rx };
          case 180:
            return { x: center - rx, y: center - ry };
          case 270:
            return { x: center - ry, y: center + rx };
          default: // 0
            return { x: gx, y: gy };
        }
      }
      
      // Convert grid coordinates to screen coordinates (with camera rotation)
      gridToScreen(gx, gy) {
        // Apply camera rotation first
        const rotated = this.rotateGridCoords(gx, gy);
        const x = rotated.x * this.tileSize + this.offsetX + this.tileSize / 2;
        const y = rotated.y * this.tileSize + this.offsetY + this.tileSize / 2;
        return { x, y };
      }
      
      // Convert screen coordinates to grid coordinates (with camera rotation)
      screenToGrid(screenX, screenY) {
        const gx = Math.floor((screenX - this.offsetX) / this.tileSize);
        const gy = Math.floor((screenY - this.offsetY) / this.tileSize);
        
        // Apply inverse camera rotation
        const rotated = this.inverseRotateGridCoords(gx, gy);
        
        return {
          x: Math.round(rotated.x),
          y: Math.round(rotated.y)
        };
      }
      
      updatePlayerTarget() {
        const pos = this.gridToScreen(this.player.gridX, this.player.gridY);
        this.player.targetRenderX = pos.x;
        this.player.targetRenderY = pos.y;
      }
      
      initField() {
        for (let y = 0; y < this.gridSize; y++) {
          this.field[y] = [];
          for (let x = 0; x < this.gridSize; x++) {
            this.field[y][x] = {
              state: CELL_STATE.EMPTY,
              plant: null,
              stage: 0,
              maxStage: 0,
              watered: false,
              growProgress: 0,
              growTime: 0
            };
          }
        }
        
        // ƒê·∫∑t ng√¥i nh√† ·ªü g√≥c tr√™n tr√°i (2x2 tiles)
        for (let y = 0; y < 2; y++) {
          for (let x = 0; x < 2; x++) {
            this.field[y][x].state = CELL_STATE.HOUSE;
          }
        }
      }
      
      setupInput() {
        // Keyboard events
        window.addEventListener('keydown', (e) => {
          this.keys.add(e.code);
          
          // Handle camera rotation keys
          if (e.code === 'KeyQ') {
            this.rotateCameraLeft();
          } else if (e.code === 'KeyE') {
            this.rotateCameraRight();
          }
          
          // Highlight button
          const btnId = 'btn' + e.key.toUpperCase();
          const btn = document.getElementById(btnId);
          if (btn) btn.classList.add('active');
        });
        
        window.addEventListener('keyup', (e) => {
          this.keys.delete(e.code);
          
          const btnId = 'btn' + e.key.toUpperCase();
          const btn = document.getElementById(btnId);
          if (btn) btn.classList.remove('active');
        });
        
        // Mouse click on canvas for movement
        this.canvas.addEventListener('click', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          
          // Account for CSS scaling - convert from CSS pixels to canvas pixels
          const scaleX = this.canvas.width / rect.width;
          const scaleY = this.canvas.height / rect.height;
          
          const screenX = (e.clientX - rect.left) * scaleX;
          const screenY = (e.clientY - rect.top) * scaleY;
          
          // Convert screen position to grid position
          const gridPos = this.screenToGrid(screenX, screenY);
          
          // Check if the position is valid
          if (gridPos.x >= 0 && gridPos.x < this.gridSize && 
              gridPos.y >= 0 && gridPos.y < this.gridSize) {
            // Check if target is not a house
            if (this.field[gridPos.y][gridPos.x].state !== CELL_STATE.HOUSE) {
              this.mouseTarget = { x: gridPos.x, y: gridPos.y };
              this.showStatus(`üñ±Ô∏è Di chuy·ªÉn ƒë·∫øn (${gridPos.x}, ${gridPos.y})`);
            } else {
              this.showStatus('‚ùå Kh√¥ng th·ªÉ ƒëi v√†o ng√¥i nh√†!');
            }
          }
        });
        
        // Button controls for movement
        ['W', 'A', 'S', 'D'].forEach(key => {
          const btn = document.getElementById('btn' + key);
          if (btn) {
            btn.addEventListener('mousedown', () => {
              this.keys.add('Key' + key);
              btn.classList.add('active');
              this.mouseTarget = null; // Cancel mouse movement when using keyboard
            });
            btn.addEventListener('mouseup', () => {
              this.keys.delete('Key' + key);
              btn.classList.remove('active');
            });
            btn.addEventListener('mouseleave', () => {
              this.keys.delete('Key' + key);
              btn.classList.remove('active');
            });
          }
        });
        
        // Camera rotation buttons
        const btnRotateLeft = document.getElementById('btnRotateLeft');
        const btnRotateRight = document.getElementById('btnRotateRight');
        
        if (btnRotateLeft) {
          btnRotateLeft.addEventListener('click', () => this.rotateCameraLeft());
        }
        if (btnRotateRight) {
          btnRotateRight.addEventListener('click', () => this.rotateCameraRight());
        }
      }
      
      // Rotate camera left (counter-clockwise) by 90¬∞
      rotateCameraLeft() {
        this.cameraAngleIndex = (this.cameraAngleIndex - 1 + CAMERA_ANGLES.length) % CAMERA_ANGLES.length;
        this.cameraAngle = CAMERA_ANGLES[this.cameraAngleIndex];
        this.updateCameraUI();
        this.updatePlayerTarget();
        this.player.renderX = this.player.targetRenderX;
        this.player.renderY = this.player.targetRenderY;
        this.showStatus(`üì∑ Camera xoay sang ${this.cameraAngle}¬∞`);
      }
      
      // Rotate camera right (clockwise) by 90¬∞
      rotateCameraRight() {
        this.cameraAngleIndex = (this.cameraAngleIndex + 1) % CAMERA_ANGLES.length;
        this.cameraAngle = CAMERA_ANGLES[this.cameraAngleIndex];
        this.updateCameraUI();
        this.updatePlayerTarget();
        this.player.renderX = this.player.targetRenderX;
        this.player.renderY = this.player.targetRenderY;
        this.showStatus(`üì∑ Camera xoay sang ${this.cameraAngle}¬∞`);
      }
      
      // Update camera angle display
      updateCameraUI() {
        const cameraAngleEl = document.getElementById('cameraAngle');
        const cameraInfoEl = document.getElementById('cameraInfo');
        if (cameraAngleEl) cameraAngleEl.textContent = `${this.cameraAngle}¬∞`;
        if (cameraInfoEl) cameraInfoEl.textContent = `üì∑ ${this.cameraAngle}¬∞`;
      }
      
      setupUI() {
        // Plant selector
        document.querySelectorAll('.plant-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.plant-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            this.selectedPlant = btn.dataset.plant;
            const plant = PLANT_CONFIG[this.selectedPlant];
            document.getElementById('plantInfo').textContent = plant.icon + ' ' + plant.name;
          });
        });
        
        // Action buttons
        document.getElementById('btnPlant').addEventListener('click', () => this.plantSeed());
        document.getElementById('btnWater').addEventListener('click', () => this.waterPlant());
        document.getElementById('btnHarvest').addEventListener('click', () => this.harvest());
      }
      
      update(deltaTime) {
        const now = performance.now();
        
        // Handle mouse-based movement (click to move)
        if (this.mouseTarget) {
          if (now - this.lastMoveTime > this.moveDelay) {
            const dx = Math.sign(this.mouseTarget.x - this.player.gridX);
            const dy = Math.sign(this.mouseTarget.y - this.player.gridY);
            
            if (dx !== 0 || dy !== 0) {
              // Move one step at a time towards target
              let newX = this.player.gridX;
              let newY = this.player.gridY;
              
              // Prioritize X movement, then Y
              if (dx !== 0) {
                newX = this.player.gridX + dx;
              } else if (dy !== 0) {
                newY = this.player.gridY + dy;
              }
              
              // Check bounds and obstacles
              if (newX >= 0 && newX < this.gridSize && 
                  newY >= 0 && newY < this.gridSize &&
                  this.field[newY][newX].state !== CELL_STATE.HOUSE) {
                this.player.gridX = newX;
                this.player.gridY = newY;
                this.updatePlayerTarget();
                this.lastMoveTime = now;
              } else {
                // Can't reach target, cancel
                this.mouseTarget = null;
              }
            } else {
              // Reached target
              this.mouseTarget = null;
            }
          }
        }
        
        // Keyboard movement with camera rotation adjustment
        if (now - this.lastMoveTime > this.moveDelay) {
          let dx = 0, dy = 0;
          
          // Simple top-down movement:
          // W = move up (decrease Y)
          // S = move down (increase Y)
          // A = move left (decrease X)
          // D = move right (increase X)
          
          if (this.keys.has('KeyW') || this.keys.has('ArrowUp')) { dy = -1; }
          if (this.keys.has('KeyS') || this.keys.has('ArrowDown')) { dy = 1; }
          if (this.keys.has('KeyA') || this.keys.has('ArrowLeft')) { dx = -1; }
          if (this.keys.has('KeyD') || this.keys.has('ArrowRight')) { dx = 1; }
          
          // Adjust movement direction based on camera rotation
          // This makes keyboard controls intuitive regardless of camera angle
          if (dx !== 0 || dy !== 0) {
            this.mouseTarget = null; // Cancel mouse movement when using keyboard
            
            // Rotate movement direction based on camera angle
            const rotatedMove = this.rotateMovementForCamera(dx, dy);
            dx = rotatedMove.dx;
            dy = rotatedMove.dy;
            
            const newX = Math.max(0, Math.min(this.gridSize - 1, this.player.gridX + dx));
            const newY = Math.max(0, Math.min(this.gridSize - 1, this.player.gridY + dy));
            
            // Kh√¥ng cho ƒëi v√†o nh√†
            if (this.field[newY][newX].state !== CELL_STATE.HOUSE) {
              this.player.gridX = newX;
              this.player.gridY = newY;
              this.updatePlayerTarget();
              this.lastMoveTime = now;
            }
          }
        }
        
        // Smooth movement using helper function defined outside
        const moveSpeed = this.player.speed * deltaTime;
        this.player.renderX = smoothMove(this.player.renderX, this.player.targetRenderX, moveSpeed);
        this.player.renderY = smoothMove(this.player.renderY, this.player.targetRenderY, moveSpeed);
        
        // C·∫≠p nh·∫≠t c√¢y tr·ªìng - ch·ªâ ki·ªÉm tra c√°c cells ƒëang growing ƒë·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng
        const cellsToRemove = [];
        for (let i = 0; i < this.growingCells.length; i++) {
          const { x, y } = this.growingCells[i];
          const cell = this.field[y][x];
          
          if (cell.state === CELL_STATE.GROWING && cell.watered) {
            cell.growProgress += deltaTime * 1000;
            if (cell.growProgress >= cell.growTime) {
              cell.stage++;
              cell.growProgress = 0;
              cell.watered = false;
              
              if (cell.stage >= cell.maxStage) {
                cell.state = CELL_STATE.READY;
                cellsToRemove.push(i);
              }
            }
          } else if (cell.state !== CELL_STATE.GROWING) {
            cellsToRemove.push(i);
          }
        }
        
        // Remove cells that are no longer growing (iterate in reverse to maintain indices)
        for (let i = cellsToRemove.length - 1; i >= 0; i--) {
          this.growingCells.splice(cellsToRemove[i], 1);
        }
        
        // Update UI
        this.updateUI();
      }
      
      // Rotate movement direction based on camera angle
      // This ensures WASD always moves "up/down/left/right" visually regardless of camera rotation
      rotateMovementForCamera(dx, dy) {
        switch (this.cameraAngle) {
          case 90:
            // Rotate 90¬∞ clockwise: (dx, dy) -> (dy, -dx)
            return { dx: dy, dy: -dx };
          case 180:
            // Rotate 180¬∞: (dx, dy) -> (-dx, -dy)
            return { dx: -dx, dy: -dy };
          case 270:
            // Rotate 270¬∞ (or -90¬∞): (dx, dy) -> (-dy, dx)
            return { dx: -dy, dy: dx };
          default: // 0
            return { dx, dy };
        }
      }
      
      updateUI() {
        document.getElementById('posInfo').textContent = `(${this.player.gridX}, ${this.player.gridY})`;
        document.getElementById('moneyInfo').textContent = 'üí∞ ' + this.money;
        document.getElementById('harvestInfo').textContent = this.harvestCount;
        
        const cell = this.field[this.player.gridY][this.player.gridX];
        let cellText = '';
        switch (cell.state) {
          case CELL_STATE.EMPTY:
            cellText = 'ƒê·∫•t tr·ªëng';
            break;
          case CELL_STATE.SEEDED:
            cellText = `H·∫°t ${PLANT_CONFIG[cell.plant].icon}`;
            break;
          case CELL_STATE.GROWING:
            const progress = Math.floor((cell.stage / cell.maxStage) * 100);
            cellText = `${PLANT_CONFIG[cell.plant].icon} ${progress}%`;
            if (!cell.watered) cellText += ' (c·∫ßn n∆∞·ªõc)';
            break;
          case CELL_STATE.READY:
            cellText = `${PLANT_CONFIG[cell.plant].icon} S·∫µn s√†ng!`;
            break;
          case CELL_STATE.HOUSE:
            cellText = 'üè† Ng√¥i nh√†';
            break;
        }
        document.getElementById('cellInfo').textContent = cellText;
        
        // Enable/disable buttons based on current cell
        document.getElementById('btnPlant').disabled = cell.state !== CELL_STATE.EMPTY;
        document.getElementById('btnWater').disabled = !(cell.state === CELL_STATE.SEEDED || (cell.state === CELL_STATE.GROWING && !cell.watered));
        document.getElementById('btnHarvest').disabled = cell.state !== CELL_STATE.READY;
      }
      
      render() {
        // Clear with grass background
        this.ctx.fillStyle = '#7CB342';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid
        for (let y = 0; y < this.gridSize; y++) {
          for (let x = 0; x < this.gridSize; x++) {
            const cell = this.field[y][x];
            const pos = this.gridToScreen(x, y);
            const screenX = pos.x - this.tileSize / 2;
            const screenY = pos.y - this.tileSize / 2;
            
            // Draw cell based on state
            switch (cell.state) {
              case CELL_STATE.HOUSE:
                this.drawHouse(screenX, screenY, x, y);
                break;
              case CELL_STATE.EMPTY:
                this.drawTile(screenX, screenY, '#8B4513');
                break;
              case CELL_STATE.SEEDED:
                this.drawTile(screenX, screenY, '#A08060');
                this.drawSeed(pos.x, pos.y);
                break;
              case CELL_STATE.GROWING:
                this.drawTile(screenX, screenY, cell.watered ? '#5D4E37' : '#8B4513');
                this.drawGrowingPlant(pos.x, pos.y, cell);
                break;
              case CELL_STATE.READY:
                this.drawTile(screenX, screenY, '#8B4513');
                this.drawReadyPlant(pos.x, pos.y, cell);
                break;
            }
            
            // Highlight current cell
            if (x === this.player.gridX && y === this.player.gridY) {
              this.drawHighlight(screenX, screenY);
            }
          }
        }
        
        // Draw player
        this.drawPlayer();
      }
      
      drawTile(x, y, color) {
        const size = this.tileSize;
        const padding = 2;
        
        // Main tile
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x + padding, y + padding, size - padding * 2, size - padding * 2);
        
        // Border
        this.ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(x + padding, y + padding, size - padding * 2, size - padding * 2);
      }
      
      drawHighlight(x, y) {
        const size = this.tileSize;
        const padding = 2;
        
        this.ctx.strokeStyle = '#FFD700';
        this.ctx.lineWidth = 3;
        this.ctx.strokeRect(x + padding, y + padding, size - padding * 2, size - padding * 2);
        
        // Glow effect
        this.ctx.shadowColor = '#FFD700';
        this.ctx.shadowBlur = 10;
        this.ctx.strokeRect(x + padding, y + padding, size - padding * 2, size - padding * 2);
        this.ctx.shadowBlur = 0;
      }
      
      drawSeed(x, y) {
        // Small seed mound
        this.ctx.fillStyle = '#6B5344';
        this.ctx.beginPath();
        this.ctx.arc(x, y, 8, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Highlight
        this.ctx.fillStyle = '#8B7355';
        this.ctx.beginPath();
        this.ctx.arc(x - 2, y - 2, 4, 0, Math.PI * 2);
        this.ctx.fill();
      }
      
      drawGrowingPlant(x, y, cell) {
        const growthPercent = cell.stage / cell.maxStage;
        const plantHeight = 10 + growthPercent * 20;
        
        // Stem
        this.ctx.strokeStyle = '#228B22';
        this.ctx.lineWidth = 2 + growthPercent * 2;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y + 10);
        this.ctx.lineTo(x, y + 10 - plantHeight);
        this.ctx.stroke();
        
        // Leaves
        this.ctx.fillStyle = '#90EE90';
        const leafSize = 5 + growthPercent * 5;
        
        // Left leaf
        this.ctx.beginPath();
        this.ctx.ellipse(x - 5, y + 10 - plantHeight/2, leafSize, leafSize/2, -0.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Right leaf
        this.ctx.beginPath();
        this.ctx.ellipse(x + 5, y + 10 - plantHeight/2, leafSize, leafSize/2, 0.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Water droplets if watered
        if (cell.watered) {
          this.ctx.fillStyle = 'rgba(100, 200, 255, 0.7)';
          for (let i = 0; i < 3; i++) {
            const dropX = x - 8 + i * 8;
            const dropY = y + 5 - i * 3;
            this.ctx.beginPath();
            this.ctx.arc(dropX, dropY, 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
        }
        
        // Progress bar
        const barWidth = 30;
        const stagePercent = cell.maxStage > 0 
          ? cell.stage / cell.maxStage + (cell.growProgress / cell.growTime / cell.maxStage)
          : 0;
        
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(x - barWidth/2, y - 20, barWidth, 4);
        this.ctx.fillStyle = cell.watered ? '#4CAF50' : '#FFC107';
        this.ctx.fillRect(x - barWidth/2, y - 20, barWidth * Math.min(stagePercent, 1), 4);
      }
      
      drawReadyPlant(x, y, cell) {
        const plant = PLANT_CONFIG[cell.plant];
        
        // Stem
        this.ctx.strokeStyle = '#228B22';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y + 10);
        this.ctx.lineTo(x, y - 15);
        this.ctx.stroke();
        
        // Leaves
        this.ctx.fillStyle = '#228B22';
        this.ctx.beginPath();
        this.ctx.ellipse(x - 8, y, 10, 4, -0.5, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.beginPath();
        this.ctx.ellipse(x + 8, y, 10, 4, 0.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Fruit/crop icon
        this.ctx.font = '20px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(plant.icon, x, y - 18);
        
        // Sparkle effect
        this.ctx.fillStyle = '#FFD700';
        const time = performance.now() / 200;
        for (let i = 0; i < 4; i++) {
          const angle = time + i * 1.57;
          const sx = x + Math.cos(angle) * 15;
          const sy = y - 10 + Math.sin(angle) * 10;
          this.ctx.beginPath();
          this.ctx.arc(sx, sy, 2, 0, Math.PI * 2);
          this.ctx.fill();
        }
      }
      
      drawHouse(x, y, gx, gy) {
        // Only draw full house from top-left corner
        if (gx === 0 && gy === 0) {
          const houseSize = this.tileSize * 2;
          const houseX = x;
          const houseY = y;
          
          // House base
          this.ctx.fillStyle = '#DEB887';
          this.ctx.fillRect(houseX + 5, houseY + 20, houseSize - 10, houseSize - 25);
          
          // Roof
          this.ctx.fillStyle = '#8B0000';
          this.ctx.beginPath();
          this.ctx.moveTo(houseX, houseY + 25);
          this.ctx.lineTo(houseX + houseSize / 2, houseY);
          this.ctx.lineTo(houseX + houseSize, houseY + 25);
          this.ctx.closePath();
          this.ctx.fill();
          
          // Door
          this.ctx.fillStyle = '#5D3A1A';
          this.ctx.fillRect(houseX + houseSize/2 - 10, houseY + houseSize - 30, 20, 25);
          
          // Window
          this.ctx.fillStyle = '#87CEEB';
          this.ctx.fillRect(houseX + 15, houseY + 35, 15, 15);
          this.ctx.fillRect(houseX + houseSize - 30, houseY + 35, 15, 15);
          
          // Window frames
          this.ctx.strokeStyle = '#5D3A1A';
          this.ctx.lineWidth = 2;
          this.ctx.strokeRect(houseX + 15, houseY + 35, 15, 15);
          this.ctx.strokeRect(houseX + houseSize - 30, houseY + 35, 15, 15);
        } else {
          // Draw empty space for other house tiles
          this.ctx.fillStyle = '#7CB342';
          this.ctx.fillRect(x, y, this.tileSize, this.tileSize);
        }
      }
      
      drawPlayer() {
        const x = this.player.renderX;
        const y = this.player.renderY;
        
        // Shadow
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y + 15, 12, 6, 0, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Body
        this.ctx.fillStyle = '#4169E1';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y, 10, 15, 0, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Head
        this.ctx.fillStyle = '#FFDAB9';
        this.ctx.beginPath();
        this.ctx.arc(x, y - 18, 10, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Hat
        this.ctx.fillStyle = '#8B4513';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y - 25, 12, 4, 0, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.fillRect(x - 7, y - 35, 14, 10);
        
        // Eyes
        this.ctx.fillStyle = '#000';
        this.ctx.beginPath();
        this.ctx.arc(x - 4, y - 20, 2, 0, Math.PI * 2);
        this.ctx.arc(x + 4, y - 20, 2, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Smile
        this.ctx.strokeStyle = '#000';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.arc(x, y - 16, 4, 0.1 * Math.PI, 0.9 * Math.PI);
        this.ctx.stroke();
      }
      
      plantSeed() {
        const cell = this.field[this.player.gridY][this.player.gridX];
        if (cell.state !== CELL_STATE.EMPTY) {
          this.showStatus('‚ùå √î n√†y ƒë√£ c√≥ c√¢y ho·∫∑c kh√¥ng th·ªÉ gieo h·∫°t!');
          return;
        }
        
        const plant = PLANT_CONFIG[this.selectedPlant];
        if (this.money < plant.seedCost) {
          this.showStatus(`‚ùå Kh√¥ng ƒë·ªß ti·ªÅn! C·∫ßn ${plant.seedCost}üí∞ ƒë·ªÉ mua h·∫°t ${plant.icon}`);
          return;
        }
        
        this.money -= plant.seedCost;
        cell.state = CELL_STATE.SEEDED;
        cell.plant = this.selectedPlant;
        cell.stage = 0;
        cell.maxStage = plant.stages;
        cell.growTime = plant.growTime;
        cell.growProgress = 0;
        cell.watered = false;
        
        this.showStatus(`üå± ƒê√£ gieo h·∫°t ${plant.icon} ${plant.name}! H√£y t∆∞·ªõi n∆∞·ªõc ƒë·ªÉ c√¢y ph√°t tri·ªÉn.`);
      }
      
      waterPlant() {
        const cell = this.field[this.player.gridY][this.player.gridX];
        const x = this.player.gridX;
        const y = this.player.gridY;
        
        if (cell.state === CELL_STATE.SEEDED) {
          cell.state = CELL_STATE.GROWING;
          cell.watered = true;
          cell.stage = 1;
          // Add to growing cells list for optimized update loop
          this.growingCells.push({ x, y });
          this.showStatus(`üíß ƒê√£ t∆∞·ªõi n∆∞·ªõc! H·∫°t b·∫Øt ƒë·∫ßu n·∫£y m·∫ßm...`);
        } else if (cell.state === CELL_STATE.GROWING && !cell.watered) {
          cell.watered = true;
          this.showStatus(`üíß ƒê√£ t∆∞·ªõi n∆∞·ªõc! C√¢y ƒëang ph√°t tri·ªÉn giai ƒëo·∫°n ${cell.stage}/${cell.maxStage}`);
        } else {
          this.showStatus('‚ùå Kh√¥ng th·ªÉ t∆∞·ªõi n∆∞·ªõc ·ªü ƒë√¢y!');
        }
      }
      
      harvest() {
        const cell = this.field[this.player.gridY][this.player.gridX];
        
        if (cell.state !== CELL_STATE.READY) {
          this.showStatus('‚ùå C√¢y ch∆∞a s·∫µn s√†ng ƒë·ªÉ thu ho·∫°ch!');
          return;
        }
        
        const plant = PLANT_CONFIG[cell.plant];
        this.money += plant.harvestValue;
        this.harvestCount++;
        
        this.showStatus(`üß∫ Thu ho·∫°ch ${plant.icon} ${plant.name}! +${plant.harvestValue}üí∞`);
        
        // Reset cell
        cell.state = CELL_STATE.EMPTY;
        cell.plant = null;
        cell.stage = 0;
        cell.maxStage = 0;
        cell.watered = false;
        cell.growProgress = 0;
      }
      
      showStatus(msg) {
        document.getElementById('statusMsg').textContent = msg;
      }
      
      gameLoop(currentTime = performance.now()) {
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;
        
        this.update(deltaTime);
        this.render();
        
        requestAnimationFrame((time) => this.gameLoop(time));
      }
    }
    
    // Start game
    window.game = new FarmGame();
  </script>
</body>
</html>
